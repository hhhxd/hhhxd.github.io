{"meta":{"title":"随缘更新","subtitle":null,"description":null,"author":"Dra","url":"http://hhhkccco.club"},"pages":[],"posts":[{"title":"js_arrayFun","slug":"js_arrayFun","date":"2019-07-12T02:47:18.000Z","updated":"2019-07-31T07:57:09.611Z","comments":true,"path":"2019/07/12/js_arrayFun/","link":"","permalink":"http://hhhkccco.club/2019/07/12/js_arrayFun/","excerpt":"","text":"笔记原网址：https://www.liaoxuefeng.com/ map操作数组的每一个元素，返回一个数组 将函数作用于Array 123456function pow(x) &#123; //pow函数 返回x的平方 return x * x;&#125;var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];var results = arr.map(pow);console.log(results); // [1, 4, 9, 16, 25, 36, 49, 64, 81] 将方法作用于Array 123var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];var results = arr.map(String); //返回数组元素转换成的字符串console.log(results); //['1', '2', '3', '4', '5', '6', '7', '8', '9'] reduce操作元素和下一个元素，再用得到的结果与再下一个元素进行操作… 将函数作用于Array，这个函数必须接收两个参数，reduce()把结果继续和序列的下一个元素做累积计算 12345var arr1 = [1,2,3,4,5]var results1 = arr1.reduce(function(x,y)&#123; return x*y &#125;)console.log(results1) // 返回数组元素的乘积 120 12345var arr2 = [1,3,5,7,9];var results2 =arr2.reduce(function (x, y) &#123; return x * 10 + y;&#125;); console.log(results2)// 返回数组元素拼接的整数 13579 filterfilter用于过滤，返回满足过滤条件的元素组成的数组回调函数接收三个形参，第一个代表元素，第二个代表索引，第三个代表数组本身 1234567var arr = ['11', '12', '13'];var r = arr.filter(function (element, index, self) &#123; console.log(element); // 依次打印'11', '12', '13' console.log(index); // 依次打印0, 1, 2 console.log(self); // 打印数组arr ['11', '12', '13'] return element % 2 != 0; // 返回奇数; 如果不reutrn 会返回空数组&#125;); 123456//数组去重var arr = ['apple', 'strawberry', 'banana', 'pear', 'apple', 'orange', 'orange', 'strawberry'];var r = arr.filter(function (element, index, self) &#123; return self.indexOf(element) === index;&#125;);console.log(r) sortsort()本身的排序是把所有元素先转换为String，再根据ASCII码进行排序，所以会出现以下情形 12['Google', 'apple', 'Microsoft'].sort(); // ['Google', 'Microsoft\", 'apple'] 小写字母a的ASCII码在大写字母之后[10, 20, 1, 2].sort(); // [1, 10, 2, 20] 字符'1'比字符'2'的ASCII码小 这种时候为了得到我们想要的结果，可以传入一个函数 1234567891011121314//字符串元素var arr = ['Google', 'apple', 'Microsoft'];arr.sort(function (s1, s2) &#123; x1 = s1.toUpperCase(); x2 = s2.toUpperCase(); if (x1 &lt; x2) &#123; return -1; &#125; if (x1 &gt; x2) &#123; return 1; &#125; return 0;&#125;); console.log(arr) //['apple', 'Google', 'Microsoft'] 123456789var arr = [10, 20, 1, 2];arr.sort(function (x, y) &#123; return x - y;&#125;);console.log(arr); // [1, 2, 10, 20]//若 x 小于 y，即 x - y 小于零，则返回一个小于零的值，数组将按照升序排列。//若 x 等于 y，则返回 0。//若 x 大于 y, 即 x - y 大于零，则返回一个大于零的值，数组将按照降序排列。","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://hhhkccco.club/tags/js/"}]},{"title":"js_this","slug":"js_this","date":"2019-07-11T08:30:08.000Z","updated":"2019-07-11T09:37:44.780Z","comments":true,"path":"2019/07/11/js_this/","link":"","permalink":"http://hhhkccco.club/2019/07/11/js_this/","excerpt":"","text":"笔记原网址：https://www.liaoxuefeng.com/ 对象的方法内，this指向该对象1234567891011var xiaoming = &#123; name: '小明', birth: 1995, age: function () &#123; var y = new Date().getFullYear(); console.log(y - this.birth); &#125;&#125;;xiaoming.age; // function xiaoming.age()xiaoming.age(); //2019年 24岁 要保证this指向正确，必须用obj.xxx()的形式调用！如果把方法拿到对象之外，调用对象的方法可以得到正常结果，但是直接调用这个函数会得到NaN;因为单独调用getAge()时，其内部this指向的不再是对象xiaoming，而是指向全局对象window;如果在严格模式use strict下，this指向undefined，执行会报错 12345678910111213function getAge() &#123; var y = new Date().getFullYear(); console.log(y - this.birth);&#125;var xiaoming = &#123; name: '小明', birth: 1995, age: getAge&#125;;xiaoming.age(); // 正常结果getAge(); // NaN 让this正确的指向方法所属的对象捕获this12345678910111213var xiaoming = &#123; name: '小明', birth: 1995, age: function () &#123; var _this = this; // 在方法内部一开始就捕获this function getAgeFromBirth() &#123; var y = new Date().getFullYear(); console.log(y - _this.birth) // 用_this而不是this &#125; return getAgeFromBirth(); &#125;&#125;;xiaoming.age(); apply &amp; call 为函数指定thisapply接收两个参数，第一个参数就是需要绑定的this变量，第二个参数是Array，表示函数本身的参数 apply()把参数打包成Array再传入。 call()把参数按顺序传入。 12345678910111213function getAge() &#123; var y = new Date().getFullYear(); console.log(y - this.birth);&#125;var xiaoming = &#123; name: '小明', birth: 1995, age: getAge&#125;;xiaoming.age(); getAge.apply(xiaoming, []); // this指向xiaoming, 参数为空getAge.apply(xiaoming); //无参数 12345678910111213function getAge() &#123; var y = new Date().getFullYear(); console.log(y - this.birth);&#125;var xiaoming = &#123; name: '小明', birth: 1995, age: getAge&#125;;xiaoming.age(); getAge.call(xiaoming, ); // this指向xiaoming, 参数为空getAge.call(xiaoming); //无参数","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://hhhkccco.club/tags/js/"}]},{"title":"js_fun","slug":"js_fun","date":"2019-07-11T06:09:07.000Z","updated":"2019-07-11T09:23:46.729Z","comments":true,"path":"2019/07/11/js_fun/","link":"","permalink":"http://hhhkccco.club/2019/07/11/js_fun/","excerpt":"","text":"笔记原网址：https://www.liaoxuefeng.com/ 定义一个函数定义函数的两种方式 1234567function ff1 () &#123; console.log('定义了一个函数ff1');&#125;var ff2 = function () &#123; console.log('定义了一个函数ff2');&#125; 不写在任何函数内，相当于绑定为window的一个属性，可以通过window.ff1,window.ff2 访问到，是全局作用域的。 区别上例中，ff1可以在定义之前调用，ff2不可以，会报错未声明：Uncaught TypeError: ff2 is not a function 123456789101112ff1();//可以调用ff2();//不可以调用function ff1 () &#123; console.log('定义了一个函数ff1');&#125;var ff2 = function () &#123; console.log('定义了一个函数ff2');&#125;ff1();//可以调用ff2();//可以调用 命名冲突如果多个js文件都使用了全局作用域的函数，为了防止出现命名冲突，可以把属于全局的函数(和变量)都绑定在一个自定义的全局对象上。 123456789var abc = &#123;&#125;; //声明全局对象abcabc.num1 = 123; //在abc上绑定一个变量num1abc.str1 = 'string'; //在abc上绑定一个变量str1abc.ff3 = function () &#123; //在abc上绑定一个函数ff3 console.log('定义了一个函数ff3');&#125;abc.ff3()//调用ff3 传参形参：函数声明时写入的参数；实参：函数调用时传入的参数； 1234567var ff4 = function (num1,num2) &#123; //num1,num2 形参 console.log(num1+num2); console.log(num2);&#125; ff4(4,3); // num1=4;num2=3; 4,3 实参; ff4(4,3,2); // num1=4;num2=3; 当实参个数大于实参时，仅取与形参数量相同的前几个，其余的下文用rest取 ff4(2); // num1=2;num2=undefined; arguments在函数内永远存在,不论有没有传入参数一般用于判断传输参数的个数，进行一些操作 123456789var ff5 = function (a, b, c) &#123; if (arguments.length === 2) &#123; // 接收2~3个参数，b是可选参数，如果只传2个参数，b默认为null： // 实际拿到的参数是a和b，c为undefined c = b; // 把b的值赋给c b = null; // b变为默认值 &#125; console.log(a,b,c) // 1 null 2&#125;ff5(1,2); 额外的参数JavaScript函数允许接收任意个参数用arguments取： 123456789101112function ff6(a,b) &#123; var i, rest = []; if (arguments.length &gt; 2) &#123; for (i = 2; i&lt;arguments.length; i++) &#123; rest.push(arguments[i]); &#125; &#125; console.log('a = ' + a); //a = 1 console.log('b = ' + b); //b = 2 console.log(rest); // [3, 4, 5]&#125;ff6(1,2,3,4,5) ES6提供了rest参数： 123456function ff7(a, b, ...rest) &#123; console.log('a = ' + a); //a = 1 console.log('b = ' + b); //b = 2 console.log(rest); // [3, 4, 5]&#125;ff7(1,2,3,4,5) 实参数量少于形参，也可以获取到rest，是一个空数组 123456function ff8(a, b, ...rest) &#123; console.log('a = ' + a); //a = 6 console.log('b = ' + b); //b = undefined console.log(rest); // []&#125;ff8(6)","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://hhhkccco.club/tags/js/"}]},{"title":"inline-block","slug":"inline-block","date":"2019-06-17T02:42:41.000Z","updated":"2019-07-11T07:38:03.080Z","comments":true,"path":"2019/06/17/inline-block/","link":"","permalink":"http://hhhkccco.club/2019/06/17/inline-block/","excerpt":"","text":"inline-block 行内块元素之间存在间隙先说原因：元素被当成行内元素排版的时候，元素之间的空白符（空格、回车换行等）都会被浏览器处理，根据white-space的处理方式（默认是normal，合并多余空白），原来HTML代码中的回车换行被转成一个空白符，所以元素之间就出现了空隙。这些元素之间的间距会随着字体的大小而变化，当font-size:20px时，间距为10px。 解决一：html结构中，行内块元素不换行让元素之间不存在空白符，就不会出现间隙。但如果行内块元素内容很多或内部结构复杂，就不适合这么做了。12345678910111213&lt;style&gt; .child &#123; display: inline-block; background-color: rgb(47, 236, 243); height: 20px; width: 100px; &#125;&lt;/style&gt;&lt;body&gt; &lt;div class=\"parent\"&gt; &lt;div class=\"child\"&gt;&lt;/div&gt;&lt;div class=\"child\"&gt;&lt;/div&gt;&lt;div class=\"child\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 解决二：父元素设置font-size: 0;既然元素之间的间距会随着字体的大小而变化，那就把父元素的font-size设置为0，再给子元素设置单独的字体大小。12345678910111213141516171819&lt;style&gt; .parent &#123; font-size: 0; &#125; .child &#123; display: inline-block; background-color: rgb(47, 236, 243); height: 20px; width: 100px; font-size: 14px; &#125;&lt;/style&gt;&lt;body&gt; &lt;div class=\"parent\"&gt; &lt;div class=\"child\"&gt;正常字体&lt;/div&gt; &lt;div class=\"child\"&gt;正常字体&lt;/div&gt; &lt;div class=\"child\"&gt;正常字体&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 解决三：父元素设置display: flex;万能flex不解释（其实是不会解释）适用：chrome21+ opera12.1+ firefox22+ safari6.1+ ie10+123456789101112131415161718&lt;style&gt; .parent &#123; display: flex; &#125; .child &#123; display: inline-block; background-color: rgb(47, 236, 243); height: 20px; width: 100px; &#125;&lt;/style&gt;&lt;body&gt; &lt;div class=\"parent\"&gt; &lt;div class=\"child\"&gt;正常字体&lt;/div&gt; &lt;div class=\"child\"&gt;正常字体&lt;/div&gt; &lt;div class=\"child\"&gt;正常字体&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 解决四： margin调整这个就真不解释了…12345678910111213141516171819&lt;style&gt; .child &#123; display: inline-block; background-color: rgb(47, 236, 243); height: 20px; width: 100px; margin-left: -5px; &#125; .child:first-child &#123; margin-left: 0x; &#125;&lt;/style&gt;&lt;body&gt; &lt;div class=\"parent\"&gt; &lt;div class=\"child\"&gt;正常字体&lt;/div&gt; &lt;div class=\"child\"&gt;正常字体&lt;/div&gt; &lt;div class=\"child\"&gt;正常字体&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;","categories":[],"tags":[{"name":"css","slug":"css","permalink":"http://hhhkccco.club/tags/css/"}]},{"title":"input相关","slug":"input","date":"2019-05-16T02:50:30.000Z","updated":"2019-07-11T07:37:56.021Z","comments":true,"path":"2019/05/16/input/","link":"","permalink":"http://hhhkccco.club/2019/05/16/input/","excerpt":"","text":"type=”checkbox”&lt;input type=&quot;checkbox&quot;&gt;勾选框的一些样式修改无效，比如background-color，写上去没有效果。 &lt;label&gt;标签修改&lt;input type=&quot;checkbox&quot;&gt;样式在&lt;input&gt;后添加&lt;label&gt;标签,通过&lt;input&gt;的id和&lt;label&gt;的for保持一致，实现绑定。 12&lt;input id=\"input1\" type=\"checkbox\"&gt;&lt;label for=\"input1\"&gt;&lt;/label&gt; css: 给label标签添加选中前样式，选中后（checked）的label添加伪元素before 12345678910111213141516171819#input1 &#123; display: none;&#125;#input1 + label &#123; display: inline-block; width: 13px; height: 13px; cursor: pointer; background-color: #3486DA;&#125;#input1:checked + label::before &#123; display: block; content: \"\\2714\"; text-align: center; font-size: 13px; color: white; &#125; 注：content: &quot;\\2714&quot;;是✔形状,常用值有： ✓ 2713 ✔ 2714 ✕ 2715 ✖ 2716 ✗ 2717 ✘ 2718 type=”radio”&lt;input type=&quot;radio&quot;&gt; 单选框，在点击单选框时可选中，但是无法通过点击文字来选中。 例如： 12&lt;input type=\"radio\" id=\"input2\" name=\"hhh\"/&gt;选项1&lt;input type=\"radio\" id=\"input3\" name=\"hhh\"/&gt;选项2 &lt;label&gt;标签，通过点击文字来选中单选框`&lt;input&gt;`标签后面加对应`&lt;label&gt;`标签 1234&lt;input type=\"radio\" id=\"input2\" name=\"hhh\"/&gt;&lt;label for=\"input2\"&gt;选项1&lt;/label&gt;&lt;input type=\"radio\" id=\"input3\" name=\"hhh\"/&gt;&lt;label for=\"input3\"&gt;选项2&lt;/label&gt; 或 用`&lt;label&gt;`标签包裹对应`&lt;input&gt;`标签 1234567&lt;label for=\"input2\"&gt; &lt;input type=\"radio\" id=\"input2\" name=\"name一致\"/&gt;选项1&lt;/label&gt;&lt;label for=\"input3\"&gt; &lt;input type=\"radio\" id=\"input3\" name=\"name一致\"/&gt;选项2&lt;/label&gt; type=”text”&lt;input type=&quot;radio&quot;&gt; 输入框，有placeholder属性可以设置预期输入值。 1&lt;input class=\"username\" type=\"text\" placeholder=\"此处输入用户名\"&gt; 预期输入值的样式修改，不同浏览器兼容：12345678910111213141516/* 谷歌 */.username::-webkit-input-placeholder &#123; color: red; background-color: #000000;&#125;/* 火狐 19+ */.username::-moz-placeholder &#123; color: red; background-color: #000000;&#125;/* 神奇的IE */.username:-ms-input-placeholder&#123; color: red; background-color: #000000;&#125; 浏览器保存了密码如果浏览器保存了账号密码，在input获取到焦点时后，鼠标移至已保存项上~直到该项被填充至input框，在这期间预期输入值的样式会被浏览器自带的丑黄色代替掉。 解决方式1： 简单粗暴地给input一个autocomplete=&quot;off&quot;属性，把选择历史值的功能关闭。 1&lt;input autocomplete=\"off\" type=\"text\"&gt; 解决方式2： :-webkit-autofill属性，给input设置一个超大的内阴影（至少比input大） 1234.username:-webkit-autofill &#123; -webkit-box-shadow: 0 0 0px 1000px #000000 inset; -webkit-text-fill-color: red;&#125;","categories":[],"tags":[{"name":"css","slug":"css","permalink":"http://hhhkccco.club/tags/css/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-05-13T08:09:33.755Z","updated":"2018-10-22T08:27:08.040Z","comments":true,"path":"2019/05/13/hello-world/","link":"","permalink":"http://hhhkccco.club/2019/05/13/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. 快速开始创建一个新帖子12$ hexo new \"My New Post\"# 新建 newBlog.md More info: Writing 运行服务器12$ hexo server# 本地预览 http://localhost:4000/ More info: Server 生成静态文件12$ hexo generate# 将md文件生成静态页面 More info: Generating 部署到远程站点12$ hexo deploy# 同步至github服务器 More info: Deployment","categories":[],"tags":[]},{"title":"Sass","slug":"Sass","date":"2019-04-22T06:56:01.000Z","updated":"2019-07-11T07:37:34.191Z","comments":true,"path":"2019/04/22/Sass/","link":"","permalink":"http://hhhkccco.club/2019/04/22/Sass/","excerpt":"","text":"$使用之前先使用$声明变量。例如： $my-color: #ccc; - 与 _sass内，- 与 _ 相通。例如： $my-color与$my_color 嵌套可进行与html结构类似的嵌套。 例如： 123456789101112//css:#content article h1 &#123; color: #333 &#125;#content article p &#123; margin-bottom: 1.4em &#125;#content aside &#123; background-color: #EEE &#125;//使用sass:#content &#123; article &#123; h1 &#123; color: #333 &#125; p &#123; margin-bottom: 1.4em &#125; &#125; aside &#123; background-color: #EEE &#125;&#125; 父选择器的标识符&amp;&amp;在使用时相当于被父选择器直接替换 例如： 1234567article a &#123; color: blue; &amp;:hover &#123; color: red &#125;&#125;//解析css为：article a &#123; color: blue &#125;article a:hover &#123; color: red &#125; 例子中，如果直接 :hover { color: red },那么整个article元素内链接的所有子元素在被hover时都会变成红色 群组选择器的嵌套减少代码量，在嵌套层级达到两层、三层时尤其明显。 例如css： 1234567#box .container h1, #box .container h2, #box .container h3 &#123; margin-bottom: .8em &#125;//需要每次重复#box .container，然后再选择h1/h2/h3,使用sass：#box .container &#123; h1, h2, h3 &#123;margin-bottom: .8em&#125;&#125; 属性的嵌套把属性名从中划线-的地方断开，在根属性后边添加一个冒号:，紧跟一个{ }块，把子属性部分写在这个{ }块中 1234567891011121314//css：nav &#123; border-style: solid; border-width: 1px; border-color: #ccc;&#125;//sass：nav &#123; border: &#123; style: solid; width: 1px; color: #ccc; &#125;&#125; 对于本就可以简写的子属性，可以以下面的方式简写，然后指明例外规则 12345678910111213//css:nav &#123; border: 1px solid #ccc; border-left: 0px; border-right: 0px;&#125;//sass:nav &#123; border: 1px solid #ccc &#123; left: 0px; right: 0px; &#125;&#125; 默认变量值一般情况下，你反复声明一个变量，只有最后一处声明有效且它会覆盖前边的值。使用sass的!default标签可以实现这个目的。它很像css属性中!important标签的对立面，不同的是!default用于变量，含义是：如果这个变量被声明赋值了，那就用它声明的值，否则就用这个默认值。例我有局部文件内容如下： 1234$fancybox-width: 400px !default;.fancybox &#123; width: $fancybox-width;&#125; 如果在导入你的sass局部文件之前声明了一个$fancybox-width变量，那么你的局部文件中对$fancybox-width赋值400px的操作就无效。如果用户没有做这样的声明，则$fancybox-width将默认为400px 嵌套导入例我有一个名为_blue-theme.scss的局部文件，内容如下： 1234aside &#123; background: blue; color: white;&#125; 然后把它导入到一个CSS规则内，如下所示： 1.blue-theme &#123;@import \"blue-theme\"&#125; 生成的结果等同于： 123456.blue-theme &#123; aside &#123; background: blue; color: #fff; &#125;&#125; 静默注释css中注释的作用包括帮助你组织样式、以后你看自己的代码时明白为什么这样写，以及简单的样式说明。但是，你并不希望每个浏览网站源码的人都能看到所有注释。 1234body &#123; color: #333; // 这种注释内容不会出现在生成的css文件中 padding: 0; /* 这种注释内容会出现在生成的css文件中 */&#125; 混入mixin@mixin定义混合器，@include调用此混合器 例如：abc.scss中的这段sass代码，定义了一个非常简单的混合器，目的是添加跨浏览器的圆角边框。 12345@mixin rounded-corners &#123; -moz-border-radius: 5px; -webkit-border-radius: 5px; border-radius: 5px;&#125; 使用如下： 123456@import 'abc.scss';notice &#123; background-color: green; border: 2px solid #00aa00; @include rounded-corners;&#125; 最终生成的css为： 1234567.notice &#123; background-color: green; border: 2px solid #00aa00; -moz-border-radius: 5px; -webkit-border-radius: 5px; border-radius: 5px;&#125; 何时使用混合器利用混合器，可以很容易地在样式表的不同地方共享样式。如果你发现自己在不停地重复一段样式，那就应该把这段样式构造成优良的混合器，尤其是这段样式本身就是一个逻辑单元，比如说是一组放在一起有意义的属性。判断一组属性是否应该组合成一个混合器，一条经验法则就是你能否为这个混合器想出一个好的名字。如果你能找到一个很好的短名字来描述这些属性修饰的样式，比如rounded-corners fancy-font或者no-bullets，那么往往能够构造一个合适的混合器。如果你找不到，这时候构造一个混合器可能并不合适。","categories":[],"tags":[{"name":"css","slug":"css","permalink":"http://hhhkccco.club/tags/css/"}]},{"title":"git","slug":"git","date":"2018-11-25T16:00:00.000Z","updated":"2018-11-26T07:11:13.830Z","comments":true,"path":"2018/11/26/git/","link":"","permalink":"http://hhhkccco.club/2018/11/26/git/","excerpt":"","text":"从远程仓库克隆项目资源管理器中右键 git bash here输入代码： 1$ git clone https://github.com/LLK/scratch-gui.git 查看分支进入项目文件夹 git bash here输入代码： 12$ git branck#查看本地分支,目前仅有一条我下载的分支 12$ git branck -a#查看所有分支(本地+远程) 创建并跳转至本地分支(命名为devh)12$ git checkout -b devh#查看所有分支 相当于两条指令: 1234$ git branch devh#创建本地分支devh$ git checkout devh#切换到devh分支 设置远程仓库地址（不是每次必须）1234$ git remote add origin http://github.com/hhhxd/lz.git#初次添加远程仓库地址$ git remote set-url origin http://github.com/hhhxd/lz.git#修改远程仓库地址 新建远程分支此时devh为本地分支，要将本地分支推送到远程仓库，成为远程分支 12$ git push --set-upstream origin devh# 将本地devh分支推送为远程分支 在项目中修改代码后,将本地文件提交到本地暂存库1234$ git add . # . 代表选择全部文件$ git commit -m ''# ''内填写本次修改的备注内容 将暂存库文件提交到远程库1$ git push 附 git gui (选中修改的文件,填写commit message,点击commit,点击push):","categories":[],"tags":[{"name":"git","slug":"git","permalink":"http://hhhkccco.club/tags/git/"}]},{"title":"vue-cli","slug":"vue-cli","date":"2018-09-18T02:25:56.000Z","updated":"2018-11-26T07:11:28.763Z","comments":true,"path":"2018/09/18/vue-cli/","link":"","permalink":"http://hhhkccco.club/2018/09/18/vue-cli/","excerpt":"","text":"准备：node(安装需要使用npm) vue-cli 搭建安装vue-cli资源管理器中shift+右键 打开cmd/powershell输入代码： 1$ npm install --global vue-cli 安装成功后，C:\\Users\\Administrator\\AppData\\Roaming\\npm下会声称几个文件： 新建项目新建文件夹，进入该文件夹，shift+右键 打开cmd/powershell输入代码： 12$ vue init webpack vuetest#初始化一个名为‘vuetest’的项目 项目信息 （手动填写）Project name (vuetest) 项目名称 Project description (A Vue.js project) 项目描述 Author（xxx） 作者 项目信息 （回车默认即可）Runtime + Compiler: recommended for most users 运行加编译 （第二个仅运行） Install vue-router? (Y/n) 是否安装vue-router Use ESLint to lint your code? (Y/n) 是否使用ESLint管理代码 Pick an ESLint preset (Use arrow keys) 选择一个ESLint预设，编写vue项目时的代码风格 Setup unit tests with Karma + Mocha? (Y/n) 是否安装单元测试 Setup e2e tests with Nightwatch(Y/n)? 是否安装e2e测试 安装依赖进入项目文件夹，shift+右键 打开cmd/powershell输入代码： 1234$ npm install # 安装依赖 （安装的依赖最终放在node_modules文件夹内）$ npm run dev # 运行项目 默认地址 http://localhost:8080","categories":[],"tags":[{"name":"vue","slug":"vue","permalink":"http://hhhkccco.club/tags/vue/"}]}]}